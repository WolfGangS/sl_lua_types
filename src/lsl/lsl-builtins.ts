import { LSLDef } from "../xml/xml-lsl-json-gen.ts";
import { ConstDef, EventDef, FuncArg, FuncDef } from "../types.d.ts";

type LSLBuiltIns = {
    consts: LSLBuiltInConst[];
    functions: LSLBuiltInFunction[];
    events: LSLBuiltInEvent[];
};

type LSLBuiltInType =
    | "integer"
    | "string"
    | "float"
    | "rotation"
    | "vector"
    | "key"
    | "list"
    | "void";

type LSLTypedName = {
    name: string;
    type: LSLBuiltInType;
};

type LSLBuiltInConst = {
    value: string;
} & LSLTypedName;

type LSLBuiltInEvent = {
    name: string;
    args: LSLTypedName[];
};

type LSLBuiltInFunction = {
    args: LSLTypedName[];
} & LSLTypedName;

export function buildLSLBuiltInsString(lsl: LSLDef): string {
    const date = new Date();
    const output: string[] = [
        `// Generated by https://github.com/WolfGangS/sl_lua_types on ${date.toString()}`,
    ];

    const builtins = buildLSLBuiltIns(lsl);

    for (const func of builtins.functions) {
        const args = func.args.map((arg) => `${arg.type} ${arg.name}`).join(
            ", ",
        );
        output.push(`${func.type} ${func.name}( ${args} )`);
    }

    for (const con of builtins.consts) {
        output.push(`const ${con.type} ${con.name} = ${con.value}`);
    }

    for (const event of builtins.events) {
        const args = event.args.map((arg) => `${arg.type} ${arg.name}`).join(
            ", ",
        );
        output.push(`event ${event.name}( ${args} )`);
    }

    return output.join("\n") + "\n";
}

export function buildLSLBuiltIns(lsl: LSLDef): LSLBuiltIns {
    const builtins: LSLBuiltIns = {
        consts: [],
        functions: [],
        events: [],
    };

    for (const cName in lsl.constants) {
        const lCon = lsl.constants[cName];
        const con: LSLBuiltInConst = {
            name: cName,
            type: castLSLTypeToBuiltIn(lCon.type),
            value: castLSLValueToBuiltIn(lCon),
        };
        builtins.consts.push(con);
    }

    for (const fName in lsl.functions) {
        builtins.functions.push(createBuiltInFunc(lsl.functions[fName]));
    }

    for (const eName in lsl.events) {
        builtins.events.push(createBuiltInEvent(lsl.events[eName]));
    }

    return builtins;
}

function createBuiltInEvent(lEvent: EventDef): LSLBuiltInEvent {
    const event: LSLBuiltInEvent = {
        name: lEvent.name,
        args: castArgs(lEvent.args),
    };
    return event;
}

function castLSLValueToBuiltIn(con: ConstDef): string {
    switch (con.type) {
        case "string": {
            const str = (con.valueRaw || "").replaceAll("\\\\u", "\\u");
            const u_str = JSON.parse(`"${str}"`);
            const b_str = u_str.replaceAll("\\\\", "\\");
            const x_str = b_str.replace(
                /(?:\\x[\da-fA-F]{2})+/g,
                (m) => decodeURIComponent(m.replace(/\\x/g, "%")),
            );
            return `"${x_str}"`;
        }
        case "integer":
        case "float":
        case "vector":
        case "rotation":
            return `${con.valueRaw}`;
        default:
            console.error(con);
            throw new Error(`Unhandled Type ${con.type}`);
    }
}

function createBuiltInFunc(lFunc: FuncDef): LSLBuiltInFunction {
    try {
        const name = lFunc.name;
        const args: LSLTypedName[] = castArgs(lFunc.args);
        return {
            name,
            type: castLSLTypeToBuiltIn(lFunc.result),
            args,
        };
    } catch (e) {
        console.error(lFunc);
        throw e;
    }
}

function castArgs(lArgs: FuncArg[]): LSLTypedName[] {
    const args: LSLTypedName[] = [];
    for (const lArg of lArgs) {
        args.push({
            name: lArg.name,
            type: castLSLTypeToBuiltIn(lArg.type, false),
        });
    }
    return args;
}

function castLSLTypeToBuiltIn(
    type: string | null,
    allowVoid: boolean = true,
): LSLBuiltInType {
    switch (type) {
        case "string":
        case "integer":
        case "list":
        case "key":
        case "vector":
        case "rotation":
        case "float":
            return type;
        case "void":
            if (!allowVoid) {
                throw "Dissalowed void";
            }
            return type;
        default:
            throw new Error(`Unhandled type '${type}'`);
    }
}
